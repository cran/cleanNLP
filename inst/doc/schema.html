<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Taylor Arnold" />


<title>A Data Model for the NLP Pipeline</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">A Data Model for the NLP Pipeline</h1>
<h4 class="author"><em>Taylor Arnold</em></h4>



<p>An annotation object is simply a named list with each item containing a data frame. These frames should be thought of as tables living inside of a single database, with keys linking each table to one another. All tables are in the second normal form of Edgar Codd. For the most part they also satisfy the third normal form, or, equivalently, the formal tidy data model of Hadley Wickham. The limited departures from this more stringent requirement are justified below wherever they exist. In every case the cause is a transitive dependency that would require a complex range join to reconstruct.</p>
<p>We were primarily considered the Java/CoreNLP backend when constructing the schema because it is the most feature-rich. With the sole exception of word embeddings in spaCy, which require a matrix-based data structure, all of the fields from the Python and R backends map seamlessly into a subset of those provided by CoreNLP. Fields where the output may differ slightly amongst backends are described in the commentary below.</p>
<p>Several standards have previously been proposed for representing textual annotations. These include the linguistic Annotation Framework, NLP Interchange Format, and CoNLL-X. The function <code>from_CoNLL</code> is included as a helper function in <strong>cleanNLP</strong> to convert from CoNLL formats into the <strong>cleanNLP</strong> data model. All of these, however, are concerned with representing annotations for interoperability between systems. Our goal is instead to create a data model well-suited to direct analysis, and therefore requires a new approach.</p>
<p>In this section each table is presented and justifications for its existence and form are given. Individual tables may be pulled out with access functions of the form <code>get_*</code>. Example tables are pulled from the State of the Union corpus, which will be discussed at length in the next section.</p>
<div id="documents" class="section level2">
<h2>Documents</h2>
<p>The documents table contains one row per document in the annotation object. What exactly constitutes a document up to the user. It might include something as granular as a paragraph or as coarse as an entire novel. For many applications, particularly stylometry, it may be useful to simultaneously work with several hierarchical levels: sections, chapters, and an entire body of work. The solution in these cases is to define a document as the smallest unit of measurement, denoting the higher-level structures as metadata. The primary key for this table is a document id, stored as an integer index. The schema is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>time</strong> date time. The time at which the parser was run on the text.</li>
<li><strong>version</strong> character. Version of CoreNLP/spaCy/tokenizers library used to parse the text.</li>
<li><strong>language</strong> character. Language of the text, in ISO 639-1 format.</li>
<li><strong>uri</strong> character. Description of the raw text location.</li>
</ul>
<p>By design, there should be no extrinsic meaning placed on this key. Other tables use it to map to one another and to the document table, but any metadata <em>about</em> the document is contained only in the document table rather than being forced into the document key. In other words, the temptation to use keys such as “Obama2016” is avoided because, while these look nice, they ultimately make programming hard.</p>
<p>These are all filled in automatically by the annotation function. Any number of additional corpora-specific metadata, such as the aforementioned section and chapter designations, may be attached as well. The document table for the example corpus is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_document</span>(obama)</code></pre></div>
<pre><code>## # A tibble: 8 × 5
##      id                time version language
##   &lt;int&gt;              &lt;dttm&gt;   &lt;chr&gt;    &lt;chr&gt;
## 1     0 2017-04-02 22:56:00   3.7.0       en
## 2     1 2017-04-02 22:57:00   3.7.0       en
## 3     2 2017-04-02 22:58:00   3.7.0       en
## 4     3 2017-04-02 22:58:00   3.7.0       en
## 5     4 2017-04-02 22:59:00   3.7.0       en
## 6     5 2017-04-02 22:59:00   3.7.0       en
## 7     6 2017-04-02 23:00:00   3.7.0       en
## 8     7 2017-04-02 23:01:00   3.7.0       en
# ... with 1 more variables: uri &lt;chr&gt;</code></pre>
<p>Notice that metadata such as the president, year, and party into the document table has been included. It may seem that common fields such as year and author should be added to the formal specification but the perceived advantage is minimal. It would still be necessary for users to manually add the content of these fields at some point as any other metadata is not unambiguously extractable from the raw text.</p>
</div>
<div id="tokens" class="section level2">
<h2>Tokens</h2>
<p>The token table contains one row for each unique token, usually a word or punctuation mark, in any document in the corpus. Any annotator that produces an output for each token has its results displayed here. These include the lemmatizer, the part of the speech tagger and speaker indicators. The schema is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>sid</strong> integer. Sentence id, starting from 0.</li>
<li><strong>tid</strong> integer. Token id, with the root of the sentence starting at 0.</li>
<li><strong>word</strong> character. Raw word in the input text.</li>
<li><strong>lemma</strong> character. Lemmatized form the token.</li>
<li><strong>upos</strong> character. Universal part of speech code.</li>
<li><strong>pos</strong> character. Language-specific part of speech code; uses the Penn Treebank codes.</li>
<li><strong>cid</strong> integer. Character offset at the start of the word in the original document.</li>
</ul>
<p>Given the annotators selected during the pipeline initialization, some of these columns may contain only missing data. A composite key exists by taking together the document id, sentence id, and token id. There is also a set of foreign keys  and  giving character offsets back into the original source document. An example of the table looks like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_token</span>(obama)</code></pre></div>
<pre><code>## # A tibble: 61,881 × 8
##       id   sid   tid      word     lemma  upos   pos   cid
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;
## 1      0     0     1     Madam     Madam  NOUN   NNP     0
## 2      0     0     2   Speaker   Speaker  NOUN   NNP     6
## 3      0     0     3         ,         ,     .     ,    13
## 4      0     0     4       Mr.       Mr.  NOUN   NNP    15
## 5      0     0     5      Vice      Vice  NOUN   NNP    19
## 6      0     0     6 President President  NOUN   NNP    24
## 7      0     0     7         ,         ,     .     ,    33
## 8      0     0     8   Members   Members  NOUN   NNP    35
## 9      0     0     9        of        of   ADP    IN    43
## 10     0     0    10  Congress  Congress  NOUN   NNP    46
## # ... with 61,871 more rows</code></pre>
<p>A phantom token “ROOT” is included at the start of each sentence (it always has <code>tid</code> equal to 0). This was added so that joins from the dependency table, which contains references to the sentence root, into the token table have no missing values.</p>
<p>The field “upos” contains the universal part of speech code, a language-agnostic classification, for the token. It could be argued that in order to maintain database normalization one should simply look up the universal part of speech code by finding the language code in the document table and joining a table mapping the Penn Treebank codes to the universal codes. This has not been done for several reasons. First, universal parts of speech are very useful for exploratory data analysis as they contain tags much more familiar to non-specialists such as “NOUN” (noun) and “CONJ” (conjunction). Asking users to apply a three table join just to access them seems overly cumbersome. Secondly, it is possible for users to use other parsers or annotation engines. These may not include granular part of speech codes and it would be difficult to figure out how to represent these if there were not a dedicated universal part of speech field.</p>
</div>
<div id="dependencies" class="section level2">
<h2>Dependencies</h2>
<p>Dependencies give the grammatical relationship between pairs of tokens within a sentence. As they are at the level of token pairs, they must be represented as a new table. Only one dependency should exist for any pair of tokens; the document id, sentence id, and source and target token ids together serve as a composite key. As dependencies exist only within a sentence, the sentence id does not need to be defined separately for the source and target. The schema is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>sid</strong> integer. Sentence id of the source token.</li>
<li><strong>tid</strong> integer. Id of the source token.</li>
<li><strong>tid_target</strong> integer. Id of the target token.</li>
<li><strong>relation</strong> character. Language-agnostic universal dependency type.</li>
<li><strong>relation_full</strong> character. Language specific universal dependency type.</li>
<li><strong>word</strong> character. The source word in the raw text.</li>
<li><strong>lemma</strong> character. Lemmatized form of the source word.</li>
<li><strong>word_target</strong> character. The target word in the raw text.</li>
<li><strong>lemma_target</strong> character. Lemmatized form of the target word.</li>
</ul>
<p>Dependencies take significantly longer to calculate than the lemmatization and part of speech tagging tasks. By default, the <code>set_language</code> function selects a fast neural network parser that requires more memory but runs nearly twice as fast as other default parsers in the CoreNLP pipeline.</p>
<p>The <code>get_dependency</code> function has an option (set to “FALSE” by default) to auto join the dependency to the target and source tokens and words from the token table. This is a common task and involves non-trivial calls to the <code>left_join</code> function making it worthwhile to include as an option. The output, with the option turned on, is given by:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_dependency</span>(obama, <span class="dt">get_token =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## # A tibble: 16,592,392 × 11
##       id   sid   tid tid_target relation relation_full  word lemma sid_target
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;int&gt;    &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;int&gt;
## 1      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          0
## 2      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          1
## 3      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          2
## 4      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          3
## 5      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          4
## 6      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          5
## 7      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          6
## 8      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          7
## 9      0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          8
## 10     0     0     0          2     root          root  &lt;NA&gt;  &lt;NA&gt;          9
## # ... with 16,592,382 more rows, and 2 more variables: word_target &lt;chr&gt;,
## #   lemma_target &lt;chr&gt;</code></pre>
<p>The word “ROOT” shows up in the first row, which would have been <code>NA</code> had sentence roots not been explicitly included in the token table.</p>
<p>Our parser produces universal dependencies, which have a language-agnostic set of relationship types with language-specific subsets pertaining to specific grammatical relationships with a particular language. For the same reasons that both the part of speech codes and universal part of speech codes are included, each of these relationship types have been added to the dependency table.</p>
</div>
<div id="named-entities" class="section level2">
<h2>Named entities</h2>
<p>Named entity recognition is the task of finding entities that can be defined by proper names, categorizing them, and standardizing their formats. The XML output of the Stanford CoreNLP pipeline places named entity information directly into their version of the token table. Doing this repeats information over every token in an entity and gives no canonical way of extracting the entirety of a single entity mention. We instead have a separate entity table, as is demanded by the normalized database structure, and record each entity mention in its own row. The schema is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>sid</strong> integer. Sentence id of the entity mention.</li>
<li><strong>tid</strong> integer. Token id at the start of the entity mention.</li>
<li><strong>tid_end</strong> integer. Token id at the end of the entity mention.</li>
<li><strong>entity_type</strong> character. Type of entity.</li>
<li><strong>entity</strong> character. Raw words of the named entity in the text.</li>
<li><strong>entity_normalized</strong> character. Normalized version of the entity.</li>
</ul>
<p>An example of the named entity table is given by:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_entity</span>(obama)</code></pre></div>
<pre><code>## # A tibble: 3,166 × 7
##       id   sid   tid tid_end  entity_type              entity
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;        &lt;chr&gt;               &lt;chr&gt;
## 1      0     1     2       2       PERSON             Speaker
## 2      0     1    10      10 ORGANIZATION            Congress
## 3      0     1    13      13         MISC           Americans
## 4      0     1    15      17         DATE Fifty-one years ago
## 5      0     1    19      21       PERSON     John F. Kennedy
## 6      0     3     1       1         DATE             Tonight
## 7      0     3    11      11         MISC            American
## 8      0     4     2       3     DURATION            a decade
## 9      0     5     2       2     DURATION               years
## 10     0     5    12      13       NUMBER           6 million
## # ... with 3,156 more rows, and 1 more variables: entity_normalized &lt;chr&gt;</code></pre>
<p>The categories available in the field <code>entity_type</code> are dependent on the models used in the annotation pipeline. The default English model selected for speed codes 2 and above include the categories: “LOCATION”, “PERSON”, “ORGANIZATION”, “MISC”, “MONEY”, “PERCENT”, “DATE” and “TIME”. The last four of these also have a normalized form, given in the final field of the table. As with the coreference table, a complete representation of the entity is given as a character string due to the difficulty in reconstructing this after the fact from the token table.</p>
</div>
<div id="coreference" class="section level2">
<h2>Coreference</h2>
<p>Coreferences link sets of tokens that refer to the same underlying person, object, or idea. One common example is the linking of a noun in one sentence to a pronoun in the next sentence. The coreference table describes these relationships but is not strictly a table of coreferences. Instead, each row represents a single mention of an expression and gives a reference id indicating all of the other mentions that it also coreferences. In theory, a given set of tokens might have two separate mentions if it refers to two different classes of references (though this is quite rare). The document, reference, and mention ids serve as a composite key for the table. The schema is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>rid</strong> integer. Relation ID.</li>
<li><strong>mid</strong> integer. Mention ID; unique to each coreference within a document.</li>
<li><strong>mention</strong> character. The mention as raw words from the text.</li>
<li><strong>mention_type</strong> character. One of “LIST”, “NOMINAL”, “PRONOMINAL”, or “PROPER”.</li>
<li><strong>number</strong> character. One of “PLURAL”, “SINGULAR”, or “UNKNOWN”.</li>
<li><strong>gender</strong> character. One of “FEMALE”, “MALE”, “NEUTRAL”, or “UNKNOWN”.</li>
<li><strong>animacy</strong> character. One of “ANIMATE”, “INANIMATE”, or “UNKNOWN”.</li>
<li><strong>sid</strong> integer. Sentence id of the coreference.</li>
<li><strong>tid</strong> integer. Token id at the start of the coreference.</li>
<li><strong>tid_end</strong> integer. Token id at the start of the coreference.</li>
<li><strong>tid_head</strong> integer. Token id of the head of the coreference.</li>
</ul>
<p>Links back into the token table for the start, end and head of the mention are given as well; these are pushed to the right of the table as they should be considered foreign keys within this table.</p>
<p>An example helps to explain exactly what the coreference table represents (the first row is removed as its mention is quite long and makes the table hard to read):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_coreference</span>(obama)[<span class="op">-</span><span class="dv">1</span>,]</code></pre></div>
<pre><code>## # A tibble: 6,984 × 12
##       id   rid   mid       mention mention_type   number  gender   animacy
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;         &lt;chr&gt;        &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;
## 1      0  1537  1531   Afghanistan       PROPER SINGULAR NEUTRAL INANIMATE
## 2      0  1537  1537   Afghanistan       PROPER SINGULAR NEUTRAL INANIMATE
## 3      0  2050  2007   a democracy      NOMINAL SINGULAR NEUTRAL INANIMATE
## 4      0  2050  2050 our democracy      NOMINAL SINGULAR NEUTRAL INANIMATE
## 5      0  1796  1746             I   PRONOMINAL SINGULAR UNKNOWN   ANIMATE
## 6      0  1796  1796             I   PRONOMINAL SINGULAR UNKNOWN   ANIMATE
## 7      0  2053  2022            we   PRONOMINAL   PLURAL UNKNOWN   ANIMATE
## 8      0  2053  2023           our   PRONOMINAL   PLURAL UNKNOWN   ANIMATE
## 9      0  2053  2044            We   PRONOMINAL   PLURAL UNKNOWN   ANIMATE
## 10     0  2053  2046            we   PRONOMINAL   PLURAL UNKNOWN   ANIMATE
## # ... with 6,974 more rows, and 4 more variables: sid &lt;int&gt;, tid &lt;int&gt;,
## #   tid_end &lt;int&gt;, tid_head &lt;int&gt;</code></pre>
<p>There is a special relationship between the reference id <code>rid</code> and the mention id <code>mid</code>. The coreference annotator selects a specific mention for each reference that gets treated as the canonical mention for the entire class. The mention id for this mention becomes the reference id for the class, as can be in the above table with rows 1, 3, 5, and 9 all corresponding to the canonical mention of their respective classes. This relationship provides a way of identifying the canonical mention within a reference class and a way of treating the coreference table as pairs of mentions rather than individual mentions joined by a given key.</p>
<p>The text of the mention itself is included within the table. This was done because as the mention may span several tokens it would otherwise be very difficult to extract this information from the token table. It is also possible, though not supported in the current CoreNLP pipeline, that a mention could consist of a set of non-contiguous tokens, making this field impossible to otherwise reconstruct.</p>
</div>
<div id="sentences" class="section level2">
<h2>Sentences</h2>
<p>The schema for sentence-level information is given by:</p>
<ul>
<li><strong>id</strong> integer. Id of the source document.</li>
<li><strong>sid</strong> integer. Sentence id.</li>
<li><strong>sentiment</strong> integer. Predicted sentiment class of the sentence, from 0 (worst) to 4 (best).</li>
</ul>
<p>An example of the output can be seen in:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_sentence</span>(obama)</code></pre></div>
<pre><code>## # A tibble: 2,988 × 3
##       id   sid sentiment
##    &lt;int&gt; &lt;int&gt;     &lt;int&gt;
## 1      0     0         1
## 2      0     1         3
## 3      0     2         1
## 4      0     3         1
## 5      0     4         2
## 6      0     5         1
## 7      0     6         3
## 8      0     7         1
## 9      0     8         1
## 10     0     9         1
## # ... with 2,978 more rows</code></pre>
<p>The underlying sentiment model is a neural network.</p>
</div>
<div id="word-vectors" class="section level2">
<h2>Word vectors</h2>
<p>Our final table in the data model stores the a relatively new concept of a word vector. Also known as word embeddings, these vectors are deterministic maps from the set of all available words into a high-dimensional, real valued vector space. Words with similar meanings or themes will tend to be clustered together in this high-dimensional space. For example, we would expect apple and pear to be very close to one another, with vegetables such as carrots, broccoli, and asparagus only slightly farther away. The embeddings can often be used as input features to fitting models on top of textual data. For a more detailed description of these embeddings, see the papers on either of the most well-known examples: GloVe  and word2vec . Only the spaCy backend to  currently supports word vectors; these are turned off by default because they take a significantly large amount of space to store. The embedding model used is a modification of the GloVe embeddings, mapping words into a 300-dimensional space. To compute the embeddings, set the  parameter of  to  prior to running the annotation.</p>
<p>Word vectors are stored in a separate table from the tokens table out of convenience rather than as a necessity of preserving the data model’s normalized schema. Due to its size and the fact that the individual components of the word embedding have no intrinsic meaning, this table is stored as a matrix. ``{r} dim(get_vector(obama))</p>
<pre><code></code></pre>
</div>
<div id="section" class="section level2">
<h2>[1] 61871 303</h2>
<p>``` The first three columns hold the keys , , and , respectively. If no embedding is computed, the function  returns an empty matrix.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
